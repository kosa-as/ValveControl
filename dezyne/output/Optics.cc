// Generated by dzn code from c:/Users/ticp/Downloads/dezyne/examples/Camera/Optics.dzn
// Dezyne --- Dezyne command line tools
//
// Copyright © 2015, 2022 Rutger van Beusekom <rutger@dezyne.org>
// Copyright © 2019, 2021 Jan (janneke) Nieuwenhuizen <janneke@gnu.org>
//
// This file is part of Dezyne.
//
// Dezyne is free software: you can redistribute it and/or modify it
// under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// Dezyne is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public
// License along with Dezyne.  If not, see <http://www.gnu.org/licenses/>.
//
// Commentary:
//
// Code:
#include "Optics.hh"
#include <dzn/locator.hh>
#include <dzn/runtime.hh>
#include <iterator>
#define STRINGIZING(x) #x
#define STR(x) STRINGIZING (x)
#define LOCATION __FILE__ ":" STR (__LINE__)
ILens::ILens (dzn::port::meta const& m)
: dzn_meta (m)
, dzn_share_p (true)
, dzn_label ("")
, dzn_state ()
, moving (false)
{}
ILens::~ILens ()= default;
void
ILens::dzn_event (char const* event)
{
  if (!dzn_share_p) return;
  dzn_label = event;
}
void
ILens::dzn_update_state (dzn::locator const& locator)
{
  if (!dzn_share_p || !dzn_label) return;
  switch (dzn::hash (dzn_label, dzn_state))
    {
      case 565166876u:
      //0:backward
      dzn_state = 5;
      break;
      case 3112815381u:
      //0:forward
      dzn_state = 5;
      break;
      case 672452365u:
      //0:stop
      dzn_state = 1;
      break;
      case 632232382u:
      //1:return
      dzn_state = 0;
      moving = false;
      break;
      case 672452523u:
      //2:stop
      dzn_state = 1;
      break;
      case 1270779051u:
      //2:stopped
      dzn_state = 3;
      moving = false;
      break;
      case 1857620579u:
      //3:<flush>
      dzn_state = 0;
      moving = false;
      break;
      case 632232698u:
      //5:return
      dzn_state = 2;
      moving = true;
      break;
      default: locator.get<dzn::illegal_handler> ().handle (LOCATION);
    }
}
void
ILens::dzn_check_bindings ()
{
  if (!this->in.forward) throw dzn::binding_error (this->dzn_meta, "in.forward");
  if (!this->in.backward) throw dzn::binding_error (this->dzn_meta, "in.backward");
  if (!this->in.stop) throw dzn::binding_error (this->dzn_meta, "in.stop");
  if (!this->out.stopped) throw dzn::binding_error (this->dzn_meta, "out.stopped");
}
namespace dzn
{
}
IFocus::IFocus (dzn::port::meta const& m)
: dzn_meta (m)
, dzn_share_p (true)
, dzn_label ("")
, dzn_state ()
, idle (true)
{}
IFocus::~IFocus ()= default;
void
IFocus::dzn_event (char const* event)
{
  if (!dzn_share_p) return;
  dzn_label = event;
}
void
IFocus::dzn_update_state (dzn::locator const& locator)
{
  if (!dzn_share_p || !dzn_label) return;
  switch (dzn::hash (dzn_label, dzn_state))
    {
      case 3877589605u:
      //0:cancel
      dzn_state = 1;
      break;
      case 380525422u:
      //0:measure
      dzn_state = 5;
      break;
      case 632232382u:
      //1:return
      dzn_state = 0;
      idle = true;
      break;
      case 3877589763u:
      //2:cancel
      dzn_state = 1;
      break;
      case 2095163550u:
      //2:maximum
      dzn_state = 3;
      idle = true;
      break;
      case 1857620579u:
      //3:<flush>
      dzn_state = 0;
      idle = true;
      break;
      case 632232698u:
      //5:return
      dzn_state = 2;
      idle = false;
      break;
      default: locator.get<dzn::illegal_handler> ().handle (LOCATION);
    }
}
void
IFocus::dzn_check_bindings ()
{
  if (!this->in.measure) throw dzn::binding_error (this->dzn_meta, "in.measure");
  if (!this->in.cancel) throw dzn::binding_error (this->dzn_meta, "in.cancel");
  if (!this->out.maximum) throw dzn::binding_error (this->dzn_meta, "out.maximum");
}
namespace dzn
{
}
IContrast::IContrast (dzn::port::meta const& m)
: dzn_meta (m)
, dzn_share_p (true)
, dzn_label ("")
, dzn_state ()
{}
IContrast::~IContrast ()= default;
void
IContrast::dzn_event (char const* event)
{
  if (!dzn_share_p) return;
  dzn_label = event;
}
void
IContrast::dzn_update_state (dzn::locator const& locator)
{
  if (!dzn_share_p || !dzn_label) return;
  switch (dzn::hash (dzn_label, dzn_state))
    {
      case 380525422u:
      //0:measure
      dzn_state = 1;
      break;
      case 935109952u:
      //1:EContrast:Blurrier
      dzn_state = 0;
      break;
      case 4240944867u:
      //1:EContrast:Sharper
      dzn_state = 0;
      break;
      default: locator.get<dzn::illegal_handler> ().handle (LOCATION);
    }
}
void
IContrast::dzn_check_bindings ()
{
  if (!this->in.measure) throw dzn::binding_error (this->dzn_meta, "in.measure");
}
namespace dzn
{
}
namespace dzn
{
  char const*
  to_cstr (::IContrast::EContrast v)
    {
      switch (v)
        {
          case ::IContrast::EContrast::Sharper: return "EContrast:Sharper";
          case ::IContrast::EContrast::Blurrier: return "EContrast:Blurrier";
        }
      return "";
    }
  template <>
  std::string
  to_string (::IContrast::EContrast v)
    {
      return to_cstr (v);
    }
}
namespace dzn
{
  ::IContrast::EContrast
  to_IContrast_EContrast (std::string s)
    {
      static std::map<std::string, ::IContrast::EContrast> m =   {
            {"EContrast:Sharper", ::IContrast::EContrast::Sharper},
            {"EContrast:Blurrier", ::IContrast::EContrast::Blurrier}};
      return m.at (s);
    }
}
IShutter::IShutter (dzn::port::meta const& m)
: dzn_meta (m)
, dzn_share_p (true)
, dzn_label ("")
, dzn_state ()
{}
IShutter::~IShutter ()= default;
void
IShutter::dzn_event (char const* event)
{
  if (!dzn_share_p) return;
  dzn_label = event;
}
void
IShutter::dzn_update_state (dzn::locator const& locator)
{
  if (!dzn_share_p || !dzn_label) return;
  switch (dzn::hash (dzn_label, dzn_state))
    {
      case 370619227u:
      //0:expose
      dzn_state = 1;
      break;
      case 632232382u:
      //1:return
      dzn_state = 0;
      break;
      default: locator.get<dzn::illegal_handler> ().handle (LOCATION);
    }
}
void
IShutter::dzn_check_bindings ()
{
  if (!this->in.expose) throw dzn::binding_error (this->dzn_meta, "in.expose");
}
namespace dzn
{
}
IOptics::IOptics (dzn::port::meta const& m)
: dzn_meta (m)
, dzn_share_p (true)
, dzn_label ("")
, dzn_state ()
, state (::IOptics::State::Idle)
{}
IOptics::~IOptics ()= default;
void
IOptics::dzn_event (char const* event)
{
  if (!dzn_share_p) return;
  dzn_label = event;
}
void
IOptics::dzn_update_state (dzn::locator const& locator)
{
  if (!dzn_share_p || !dzn_label) return;
  switch (dzn::hash (dzn_label, dzn_state))
    {
      case 3877589605u:
      //0:cancel
      dzn_state = 1;
      break;
      case 55388023u:
      //0:prepare
      dzn_state = 6;
      break;
      case 632232382u:
      //1:return
      dzn_state = 0;
      state = IOptics::State::Idle;
      break;
      case 3877589763u:
      //2:cancel
      dzn_state = 1;
      break;
      case 4039798628u:
      //2:capture
      dzn_state = 1;
      break;
      case 1857620658u:
      //4:<flush>
      dzn_state = 2;
      state = IOptics::State::Ready;
      break;
      case 3877590000u:
      //5:cancel
      dzn_state = 1;
      break;
      case 4039798865u:
      //5:capture
      dzn_state = 1;
      break;
      case 2998451582u:
      //5:ready
      dzn_state = 4;
      state = IOptics::State::Prepare;
      break;
      case 632232777u:
      //6:return
      dzn_state = 5;
      state = IOptics::State::Prepare;
      break;
      default: locator.get<dzn::illegal_handler> ().handle (LOCATION);
    }
}
void
IOptics::dzn_check_bindings ()
{
  if (!this->in.prepare) throw dzn::binding_error (this->dzn_meta, "in.prepare");
  if (!this->in.capture) throw dzn::binding_error (this->dzn_meta, "in.capture");
  if (!this->in.cancel) throw dzn::binding_error (this->dzn_meta, "in.cancel");
  if (!this->out.ready) throw dzn::binding_error (this->dzn_meta, "out.ready");
}
namespace dzn
{
}
namespace skel
{
  Lens::Lens (dzn::locator const& locator)
  : dzn_meta (  {"Lens","Lens",0,  {},  {},  {[this] ()
            {
              port.dzn_check_bindings ();
            }}})
  , dzn_runtime (locator.get<dzn::runtime> ())
  , dzn_locator (locator)
  , port (  {  {"port",&port,this,&dzn_meta},  {"port",0,0,0}},this)
    {
      this->port.in.forward = [this] ()
        {
          this->dzn_out_port = &this->port.in.forward.dzn_out_binding;
          this->port_forward ();
        };
      this->port.in.backward = [this] ()
        {
          this->dzn_out_port = &this->port.in.backward.dzn_out_binding;
          this->port_backward ();
        };
      this->port.in.stop = [this] ()
        {
          this->dzn_out_port = &this->port.in.stop.dzn_out_binding;
          this->port_stop ();
        };
    }
  Lens::~Lens ()
    {}
  void
  Lens::port_stopped ()
    {
      this->port.out.stopped ();
    }
}
namespace skel
{
  Contrast::Contrast (dzn::locator const& locator)
  : dzn_meta (  {"Contrast","Contrast",0,  {},  {},  {[this] ()
            {
              port.dzn_check_bindings ();
            }}})
  , dzn_runtime (locator.get<dzn::runtime> ())
  , dzn_locator (locator)
  , port (  {  {"port",&port,this,&dzn_meta},  {"port",0,0,0}},this)
    {
      this->port.in.measure = [this] ()
        {
          this->dzn_out_port = &this->port.in.measure.dzn_out_binding;
          this->dzn_reply_IContrast_EContrast = &this->port.in.measure.reply;
          return this->port_measure ();
        };
    }
  Contrast::~Contrast ()
    {}
}
FocusControl::FocusControl (dzn::locator const& locator)
: dzn_meta ({"FocusControl","FocusControl",0,  {},  {},  {[this] ()
        {
          port.dzn_check_bindings ();
        }, [this] ()
        {
          sensor.dzn_check_bindings ();
        }, [this] ()
        {
          lens.dzn_check_bindings ();
        }}})
, dzn_runtime (locator.get<dzn::runtime> ())
, dzn_locator (locator)
, contrast_was (::IContrast::EContrast::Blurrier)
, port ({  {"port",&port,this,&dzn_meta},  {"port",0,0,0}},this)
, sensor ({  {"sensor",0,0,0},  {"sensor",&sensor,this,&dzn_meta}},this)
, lens ({  {"lens",0,0,0},  {"lens",&lens,this,&dzn_meta}},this)
{
  dzn_runtime.native (this) = true;
  this->dzn_meta.require =   {&sensor.dzn_meta,&lens.dzn_meta};
  this->port.in.measure = [this] ()
    {
      this->dzn_out_port = &this->port.in.measure.dzn_out_binding;
      this->port_measure ();
    };
  this->port.in.cancel = [this] ()
    {
      this->dzn_out_port = &this->port.in.cancel.dzn_out_binding;
      this->port_cancel ();
    };
  this->lens.out.stopped = [this] ()
    {
      this->lens_stopped ();
    };
}
void
FocusControl::port_measure ()
{
  this->contrast_was = this->sensor.in.measure ();
  this->lens.in.forward ();
}
void
FocusControl::port_cancel ()
{
  this->lens.in.stop ();
}
void
FocusControl::lens_stopped ()
{
  ::IContrast::EContrast contrast_is = this->sensor.in.measure ();
  if ((this->contrast_was == ::IContrast::EContrast::Sharper) && (contrast_is == ::IContrast::EContrast::Blurrier)) this->port.out.maximum ();
  else if ((this->contrast_was == ::IContrast::EContrast::Sharper) && (contrast_is == ::IContrast::EContrast::Sharper)) this->lens.in.forward ();
  else this->lens.in.backward ();
  this->contrast_was = contrast_is;
}
namespace skel
{
  Shutter::Shutter (dzn::locator const& locator)
  : dzn_meta (  {"Shutter","Shutter",0,  {},  {},  {[this] ()
            {
              port.dzn_check_bindings ();
            }}})
  , dzn_runtime (locator.get<dzn::runtime> ())
  , dzn_locator (locator)
  , port (  {  {"port",&port,this,&dzn_meta},  {"port",0,0,0}},this)
    {
      this->port.in.expose = [this] ()
        {
          this->dzn_out_port = &this->port.in.expose.dzn_out_binding;
          this->port_expose ();
        };
    }
  Shutter::~Shutter ()
    {}
}
OpticsControl::OpticsControl (dzn::locator const& locator)
: dzn_meta ({"OpticsControl","OpticsControl",0,  {},  {},  {[this] ()
        {
          port.dzn_check_bindings ();
        }, [this] ()
        {
          shutter.dzn_check_bindings ();
        }, [this] ()
        {
          focus.dzn_check_bindings ();
        }}})
, dzn_runtime (locator.get<dzn::runtime> ())
, dzn_locator (locator)
, port ({  {"port",&port,this,&dzn_meta},  {"port",0,0,0}},this)
, shutter ({  {"shutter",0,0,0},  {"shutter",&shutter,this,&dzn_meta}},this)
, focus ({  {"focus",0,0,0},  {"focus",&focus,this,&dzn_meta}},this)
{
  dzn_runtime.native (this) = true;
  this->dzn_meta.require =   {&shutter.dzn_meta,&focus.dzn_meta};
  this->port.in.prepare = [this] ()
    {
      this->dzn_out_port = &this->port.in.prepare.dzn_out_binding;
      this->port_prepare ();
    };
  this->port.in.capture = [this] ()
    {
      this->dzn_out_port = &this->port.in.capture.dzn_out_binding;
      this->port_capture ();
    };
  this->port.in.cancel = [this] ()
    {
      this->dzn_out_port = &this->port.in.cancel.dzn_out_binding;
      this->port_cancel ();
    };
  this->focus.out.maximum = [this] ()
    {
      this->focus_maximum ();
    };
}
void
OpticsControl::port_prepare ()
{
  this->focus.in.measure ();
}
void
OpticsControl::port_capture ()
{
  this->focus.in.cancel ();
  this->shutter.in.expose ();
}
void
OpticsControl::port_cancel ()
{
  this->focus.in.cancel ();
}
void
OpticsControl::focus_maximum ()
{
  this->port.out.ready ();
}
Focus::Focus (dzn::locator const& locator)
: dzn_meta ({"Focus","Focus",0,  {},  {},  {[this] ()
        {
          port.dzn_check_bindings ();
        }}})
, dzn_runtime (locator.get<dzn::runtime> ())
, dzn_locator (locator)
, focus (dzn_locator)
, sensor (dzn_locator)
, lens (dzn_locator)
, port (this->focus.port)
{
  focus.port.dzn_meta.require.name = "port";
  dzn_meta.require =   {};
  dzn_meta.children =   {&focus.dzn_meta,&sensor.dzn_meta,&lens.dzn_meta};
  focus.dzn_meta.parent = &dzn_meta;
  focus.dzn_meta.name = "focus";
  sensor.dzn_meta.parent = &dzn_meta;
  sensor.dzn_meta.name = "sensor";
  lens.dzn_meta.parent = &dzn_meta;
  lens.dzn_meta.name = "lens";
  dzn::connect (this->lens.port, this->focus.lens);
  dzn::connect (this->sensor.port, this->focus.sensor);
}
Optics::Optics (dzn::locator const& locator)
: dzn_meta ({"Optics","Optics",0,  {},  {},  {[this] ()
        {
          port.dzn_check_bindings ();
        }}})
, dzn_runtime (locator.get<dzn::runtime> ())
, dzn_locator (locator)
, optics (dzn_locator)
, shutter (dzn_locator)
, focus (dzn_locator)
, port (this->optics.port)
{
  optics.port.dzn_meta.require.name = "port";
  dzn_meta.require =   {};
  dzn_meta.children =   {&optics.dzn_meta,&shutter.dzn_meta,&focus.dzn_meta};
  optics.dzn_meta.parent = &dzn_meta;
  optics.dzn_meta.name = "optics";
  shutter.dzn_meta.parent = &dzn_meta;
  shutter.dzn_meta.name = "shutter";
  focus.dzn_meta.parent = &dzn_meta;
  focus.dzn_meta.name = "focus";
  dzn::connect (this->shutter.port, this->optics.shutter);
  dzn::connect (this->focus.port, this->optics.focus);
}
// version 2.18.3

