// Generated by dzn code from c:/Users/ticp/Downloads/dezyne/examples/Camera/Optics.dzn
// Dezyne --- Dezyne command line tools
//
// Copyright © 2015, 2022 Rutger van Beusekom <rutger@dezyne.org>
// Copyright © 2019, 2021 Jan (janneke) Nieuwenhuizen <janneke@gnu.org>
//
// This file is part of Dezyne.
//
// Dezyne is free software: you can redistribute it and/or modify it
// under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// Dezyne is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public
// License along with Dezyne.  If not, see <http://www.gnu.org/licenses/>.
//
// Commentary:
//
// Code:
#include <dzn/runtime.hh>
namespace dzn
{
  struct locator;
  struct runtime;
}
#include <iostream>
#include <vector>
#include <map>
#ifndef ILENS_HH
#define ILENS_HH
struct ILens
{
  dzn::port::meta dzn_meta;
  struct
    {
      dzn::in::event<void ()> forward;
      dzn::in::event<void ()> backward;
      dzn::in::event<void ()> stop;
    } in;
  struct
    {
      dzn::out::event<void ()> stopped;
    } out;
  bool dzn_share_p;
  char const* dzn_label;
  int dzn_state;
  bool moving;
  ILens (dzn::port::meta const& m);
  template <typename Component>
  ILens (dzn::port::meta const& m, Component* that)
  : dzn_meta (m)
  , dzn_share_p (true)
  , dzn_label ("")
  , dzn_state ()
  , moving (false)
    {
      in.forward.set (that, this, "forward");
      in.backward.set (that, this, "backward");
      in.stop.set (that, this, "stop");
      out.stopped.set (that, this, "stopped");
    }
  virtual ~ILens ();
  void dzn_event (char const* event);
  void dzn_update_state (dzn::locator const& locator);
  void dzn_check_bindings ();
};
namespace dzn
{
  inline void connect (::ILens& provide, ::ILens& require)
    {
      require.out.stopped.other_port_update = provide.out.stopped.port_update;
      provide.out.stopped = require.out.stopped;
      require.in.forward = provide.in.forward;
      require.in.backward = provide.in.backward;
      require.in.stop = provide.in.stop;
      provide.dzn_meta.require = require.dzn_meta.require;
      require.dzn_meta.provide = provide.dzn_meta.provide;
      provide.dzn_share_p = require.dzn_share_p = provide.dzn_share_p && require.dzn_share_p;
    }
}
#endif // ILENS_HH
#ifndef IFOCUS_HH
#define IFOCUS_HH
struct IFocus
{
  dzn::port::meta dzn_meta;
  struct
    {
      dzn::in::event<void ()> measure;
      dzn::in::event<void ()> cancel;
    } in;
  struct
    {
      dzn::out::event<void ()> maximum;
    } out;
  bool dzn_share_p;
  char const* dzn_label;
  int dzn_state;
  bool idle;
  IFocus (dzn::port::meta const& m);
  template <typename Component>
  IFocus (dzn::port::meta const& m, Component* that)
  : dzn_meta (m)
  , dzn_share_p (true)
  , dzn_label ("")
  , dzn_state ()
  , idle (true)
    {
      in.measure.set (that, this, "measure");
      in.cancel.set (that, this, "cancel");
      out.maximum.set (that, this, "maximum");
    }
  virtual ~IFocus ();
  void dzn_event (char const* event);
  void dzn_update_state (dzn::locator const& locator);
  void dzn_check_bindings ();
};
namespace dzn
{
  inline void connect (::IFocus& provide, ::IFocus& require)
    {
      require.out.maximum.other_port_update = provide.out.maximum.port_update;
      provide.out.maximum = require.out.maximum;
      require.in.measure = provide.in.measure;
      require.in.cancel = provide.in.cancel;
      provide.dzn_meta.require = require.dzn_meta.require;
      require.dzn_meta.provide = provide.dzn_meta.provide;
      provide.dzn_share_p = require.dzn_share_p = provide.dzn_share_p && require.dzn_share_p;
    }
}
#endif // IFOCUS_HH
#ifndef ICONTRAST_HH
#define ICONTRAST_HH
struct IContrast
{
  enum struct EContrast
    {
      Sharper,Blurrier
    };
  dzn::port::meta dzn_meta;
  struct
    {
      dzn::in::event<::IContrast::EContrast ()> measure;
    } in;
  struct
    {
    } out;
  bool dzn_share_p;
  char const* dzn_label;
  int dzn_state;
  IContrast (dzn::port::meta const& m);
  template <typename Component>
  IContrast (dzn::port::meta const& m, Component* that)
  : dzn_meta (m)
  , dzn_share_p (true)
  , dzn_label ("")
  , dzn_state ()
    {
      in.measure.set (that, this, "measure");
    }
  virtual ~IContrast ();
  void dzn_event (char const* event);
  void dzn_update_state (dzn::locator const& locator);
  void dzn_check_bindings ();
};
namespace dzn
{
  inline void connect (::IContrast& provide, ::IContrast& require)
    {
      require.in.measure = provide.in.measure;
      provide.dzn_meta.require = require.dzn_meta.require;
      require.dzn_meta.provide = provide.dzn_meta.provide;
      provide.dzn_share_p = require.dzn_share_p = provide.dzn_share_p && require.dzn_share_p;
    }
}
namespace dzn
{
  char const* to_cstr (::IContrast::EContrast v);
  template <>
  std::string to_string (::IContrast::EContrast v);
}
template <typename Char, typename Traits>
std::basic_ostream<Char, Traits> & operator << (std::basic_ostream<Char, Traits>& os, ::IContrast::EContrast v)
{
  return os << dzn::to_cstr (v);
}
namespace dzn
{
  ::IContrast::EContrast to_IContrast_EContrast (std::string s);
}
#endif // ICONTRAST_HH
#ifndef ISHUTTER_HH
#define ISHUTTER_HH
struct IShutter
{
  dzn::port::meta dzn_meta;
  struct
    {
      dzn::in::event<void ()> expose;
    } in;
  struct
    {
    } out;
  bool dzn_share_p;
  char const* dzn_label;
  int dzn_state;
  IShutter (dzn::port::meta const& m);
  template <typename Component>
  IShutter (dzn::port::meta const& m, Component* that)
  : dzn_meta (m)
  , dzn_share_p (true)
  , dzn_label ("")
  , dzn_state ()
    {
      in.expose.set (that, this, "expose");
    }
  virtual ~IShutter ();
  void dzn_event (char const* event);
  void dzn_update_state (dzn::locator const& locator);
  void dzn_check_bindings ();
};
namespace dzn
{
  inline void connect (::IShutter& provide, ::IShutter& require)
    {
      require.in.expose = provide.in.expose;
      provide.dzn_meta.require = require.dzn_meta.require;
      require.dzn_meta.provide = provide.dzn_meta.provide;
      provide.dzn_share_p = require.dzn_share_p = provide.dzn_share_p && require.dzn_share_p;
    }
}
#endif // ISHUTTER_HH
#ifndef IOPTICS_HH
#define IOPTICS_HH
struct IOptics
{
  enum struct State
    {
      Idle,Prepare,Ready
    };
  dzn::port::meta dzn_meta;
  struct
    {
      dzn::in::event<void ()> prepare;
      dzn::in::event<void ()> capture;
      dzn::in::event<void ()> cancel;
    } in;
  struct
    {
      dzn::out::event<void ()> ready;
    } out;
  bool dzn_share_p;
  char const* dzn_label;
  int dzn_state;
  ::IOptics::State state;
  IOptics (dzn::port::meta const& m);
  template <typename Component>
  IOptics (dzn::port::meta const& m, Component* that)
  : dzn_meta (m)
  , dzn_share_p (true)
  , dzn_label ("")
  , dzn_state ()
  , state (::IOptics::State::Idle)
    {
      in.prepare.set (that, this, "prepare");
      in.capture.set (that, this, "capture");
      in.cancel.set (that, this, "cancel");
      out.ready.set (that, this, "ready");
    }
  virtual ~IOptics ();
  void dzn_event (char const* event);
  void dzn_update_state (dzn::locator const& locator);
  void dzn_check_bindings ();
};
namespace dzn
{
  inline void connect (::IOptics& provide, ::IOptics& require)
    {
      require.out.ready.other_port_update = provide.out.ready.port_update;
      provide.out.ready = require.out.ready;
      require.in.prepare = provide.in.prepare;
      require.in.capture = provide.in.capture;
      require.in.cancel = provide.in.cancel;
      provide.dzn_meta.require = require.dzn_meta.require;
      require.dzn_meta.provide = provide.dzn_meta.provide;
      provide.dzn_share_p = require.dzn_share_p = provide.dzn_share_p && require.dzn_share_p;
    }
}
#endif // IOPTICS_HH
#ifndef SKEL_LENS_HH
#define SKEL_LENS_HH
namespace skel
{
  struct Lens: public dzn::component
    {
      dzn::meta dzn_meta;
      dzn::runtime& dzn_runtime;
      dzn::locator const& dzn_locator;
      std::function<void ()>* dzn_out_port;
      ::ILens port;
      Lens (dzn::locator const& locator);
      virtual ~Lens ();
      protected:
      void port_stopped ();
      private:
      virtual void port_forward () = 0;
      virtual void port_backward () = 0;
      virtual void port_stop () = 0;
    };
}
#endif // SKEL_LENS_HH
#ifndef SKEL_CONTRAST_HH
#define SKEL_CONTRAST_HH
namespace skel
{
  struct Contrast: public dzn::component
    {
      dzn::meta dzn_meta;
      dzn::runtime& dzn_runtime;
      dzn::locator const& dzn_locator;
      ::IContrast::EContrast* dzn_reply_IContrast_EContrast;
      std::function<void ()>* dzn_out_port;
      ::IContrast port;
      Contrast (dzn::locator const& locator);
      virtual ~Contrast ();
      protected:
      private:
      virtual ::IContrast::EContrast port_measure () = 0;
    };
}
#endif // SKEL_CONTRAST_HH
#ifndef FOCUSCONTROL_HH
#define FOCUSCONTROL_HH
struct FocusControl: public dzn::component
{
  dzn::meta dzn_meta;
  dzn::runtime& dzn_runtime;
  dzn::locator const& dzn_locator;
  ::IContrast::EContrast contrast_was;
  ::IContrast::EContrast* dzn_reply_IContrast_EContrast;
  std::function<void ()>* dzn_out_port;
  ::IFocus port;
  ::IContrast sensor;
  ::ILens lens;
  FocusControl (dzn::locator const& locator);
  private:
  void port_measure ();
  void port_cancel ();
  void lens_stopped ();
};
#endif // FOCUSCONTROL_HH
#ifndef SKEL_SHUTTER_HH
#define SKEL_SHUTTER_HH
namespace skel
{
  struct Shutter: public dzn::component
    {
      dzn::meta dzn_meta;
      dzn::runtime& dzn_runtime;
      dzn::locator const& dzn_locator;
      std::function<void ()>* dzn_out_port;
      ::IShutter port;
      Shutter (dzn::locator const& locator);
      virtual ~Shutter ();
      protected:
      private:
      virtual void port_expose () = 0;
    };
}
#endif // SKEL_SHUTTER_HH
#ifndef OPTICSCONTROL_HH
#define OPTICSCONTROL_HH
struct OpticsControl: public dzn::component
{
  dzn::meta dzn_meta;
  dzn::runtime& dzn_runtime;
  dzn::locator const& dzn_locator;
  std::function<void ()>* dzn_out_port;
  ::IOptics port;
  ::IShutter shutter;
  ::IFocus focus;
  OpticsControl (dzn::locator const& locator);
  private:
  void port_prepare ();
  void port_capture ();
  void port_cancel ();
  void focus_maximum ();
};
#endif // OPTICSCONTROL_HH
#ifndef FOCUS_HH
#define FOCUS_HH
#include "Contrast.hh"
#include "Lens.hh"
struct Focus: public dzn::component
{
  dzn::meta dzn_meta;
  dzn::runtime& dzn_runtime;
  dzn::locator const& dzn_locator;
  ::FocusControl focus;
  ::Contrast sensor;
  ::Lens lens;
  ::IFocus& port;
  Focus (dzn::locator const& locator);
};
#endif // FOCUS_HH
#ifndef OPTICS_HH
#define OPTICS_HH
#include "Shutter.hh"
struct Optics: public dzn::component
{
  dzn::meta dzn_meta;
  dzn::runtime& dzn_runtime;
  dzn::locator const& dzn_locator;
  ::OpticsControl optics;
  ::Shutter shutter;
  ::Focus focus;
  ::IOptics& port;
  Optics (dzn::locator const& locator);
};
#endif // OPTICS_HH
// version 2.18.3
